import { PublicKey } from '@solana/web3.js';
import QRCodeModal from '@walletconnect/qrcode-modal';
import WalletConnectClient from '@walletconnect/sign-client';
import { getSdkError, parseAccountId } from '@walletconnect/utils';
import base58 from 'bs58';
import { ClientNotInitializedError, QRCodeModalError } from './errors.js';
export var WalletConnectChainID;
(function (WalletConnectChainID) {
    WalletConnectChainID["Mainnet"] = "solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ";
    WalletConnectChainID["Devnet"] = "solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K";
})(WalletConnectChainID || (WalletConnectChainID = {}));
export var WalletConnectRPCMethods;
(function (WalletConnectRPCMethods) {
    WalletConnectRPCMethods["signTransaction"] = "solana_signTransaction";
    WalletConnectRPCMethods["signMessage"] = "solana_signMessage";
})(WalletConnectRPCMethods || (WalletConnectRPCMethods = {}));
const getConnectParams = (chainId, pairingTopic) => ({
    requiredNamespaces: {
        solana: {
            chains: [chainId],
            methods: [WalletConnectRPCMethods.signTransaction, WalletConnectRPCMethods.signMessage],
            events: [],
        },
    },
    pairingTopic,
});
export class WalletConnectWallet {
    constructor(config) {
        this._options = config.options;
        this._network = config.network;
    }
    async connect() {
        const client = this._client ?? (await WalletConnectClient.init(this._options));
        const sessions = client.find(getConnectParams(this._network)).filter((s) => s.acknowledged);
        if (sessions.length) {
            // select last matching session
            this._session = sessions[sessions.length - 1];
            // We assign this variable only after we're sure we've received approval
            this._client = client;
            return {
                publicKey: this.publicKey,
            };
        }
        else {
            const { uri, approval } = await client.connect(getConnectParams(this._network));
            return new Promise((resolve, reject) => {
                if (uri) {
                    QRCodeModal.open(uri, () => {
                        reject(new QRCodeModalError());
                    });
                }
                approval()
                    .then((session) => {
                    this._session = session;
                    // We assign this variable only after we're sure we've received approval
                    this._client = client;
                    resolve({ publicKey: this.publicKey });
                })
                    .catch(reject)
                    .finally(() => {
                    QRCodeModal.close();
                });
            });
        }
    }
    async disconnect() {
        if (this._client && this._session) {
            await this._client.disconnect({
                topic: this._session.topic,
                reason: getSdkError('USER_DISCONNECTED'),
            });
            this._session = undefined;
        }
        else {
            throw new ClientNotInitializedError();
        }
    }
    get client() {
        if (this._client) {
            // TODO: using client.off throws an error
            return Object.assign({}, this._client, { off: this._client.removeListener });
            // return this._client;
        }
        else {
            throw new ClientNotInitializedError();
        }
    }
    get publicKey() {
        if (this._client && this._session) {
            const { address } = parseAccountId(this._session.namespaces.solana.accounts[0]);
            return new PublicKey(address);
        }
        else {
            throw new ClientNotInitializedError();
        }
    }
    async signTransaction(transaction) {
        if (this._client && this._session) {
            const { signature } = await this._client.request({
                chainId: this._network,
                topic: this._session.topic,
                request: { method: WalletConnectRPCMethods.signTransaction, params: { ...transaction } },
            });
            transaction.addSignature(this.publicKey, Buffer.from(base58.decode(signature)));
            return transaction;
        }
        else {
            throw new ClientNotInitializedError();
        }
    }
    async signMessage(message) {
        if (this._client && this._session) {
            const { signature } = await this._client.request({
                // The network does not change the output of message signing, but this is a required parameter for SignClient
                chainId: this._network,
                topic: this._session.topic,
                request: {
                    method: WalletConnectRPCMethods.signMessage,
                    params: { pubkey: this.publicKey.toString(), message: base58.encode(message) },
                },
            });
            return base58.decode(signature);
        }
        else {
            throw new ClientNotInitializedError();
        }
    }
}
//# sourceMappingURL=adapter.js.map
import{RELAYER_DEFAULT_PROTOCOL as F,RELAYER_EVENTS as ge,Store as U,Core as ue}from"@walletconnect/core";import{generateChildLogger as k,getLoggerContext as j,getDefaultLoggerOptions as me}from"@walletconnect/logger";import{IEngine as we,IExpirer as ye,IJsonRpcHistory as _e,ISignClient as Ee}from"@walletconnect/types";import{createDelayedPromise as x,engineEvent as p,getInternalError as c,calcExpiry as E,parseUri as fe,getSdkError as f,isSessionCompatible as ve,isExpired as P,isValidParams as u,isUndefined as Ie,isValidRequiredNamespaces as Re,isValidRelays as Se,isValidUrl as Ne,isValidNamespaces as J,isConformingNamespaces as W,isValidString as b,isValidErrorReason as xe,isValidRelay as Pe,isValidController as Te,isValidNamespacesChainId as Z,isValidRequest as Oe,isValidNamespacesRequest as Ve,isValidResponse as qe,isValidEvent as Le,isValidNamespacesEvent as De,generateRandomBytes32 as be,formatUri as Ae,parseExpirerTarget as Ce,isValidId as $e,formatTopicTarget as Ge,formatIdTarget as ze,getAppMetadata as Me}from"@walletconnect/utils";import Ke from"pino";import{ONE_DAY as Ue,THIRTY_DAYS as B,SEVEN_DAYS as ke,FIVE_MINUTES as A,toMiliseconds as je}from"@walletconnect/time";import{isJsonRpcResult as S,isJsonRpcError as v,formatJsonRpcRequest as Q,formatJsonRpcResult as Je,formatJsonRpcError as Ye,isJsonRpcRequest as Xe,isJsonRpcResponse as He}from"@walletconnect/jsonrpc-utils";import{HEARTBEAT_EVENTS as Fe}from"@walletconnect/heartbeat";function d(){this._events=this._events||{},this._maxListeners=this._maxListeners||void 0}var C=d;d.EventEmitter=d,d.prototype._events=void 0,d.prototype._maxListeners=void 0,d.defaultMaxListeners=10,d.prototype.setMaxListeners=function(o){if(!We(o)||o<0||isNaN(o))throw TypeError("n must be a positive number");return this._maxListeners=o,this},d.prototype.emit=function(o){var i,e,t,s,r,n;if(this._events||(this._events={}),o==="error"&&(!this._events.error||q(this._events.error)&&!this._events.error.length)){if(i=arguments[1],i instanceof Error)throw i;var a=new Error('Uncaught, unspecified "error" event. ('+i+")");throw a.context=i,a}if(e=this._events[o],ee(e))return!1;if(I(e))switch(arguments.length){case 1:e.call(this);break;case 2:e.call(this,arguments[1]);break;case 3:e.call(this,arguments[1],arguments[2]);break;default:s=Array.prototype.slice.call(arguments,1),e.apply(this,s)}else if(q(e))for(s=Array.prototype.slice.call(arguments,1),n=e.slice(),t=n.length,r=0;r<t;r++)n[r].apply(this,s);return!0},d.prototype.addListener=function(o,i){var e;if(!I(i))throw TypeError("listener must be a function");return this._events||(this._events={}),this._events.newListener&&this.emit("newListener",o,I(i.listener)?i.listener:i),this._events[o]?q(this._events[o])?this._events[o].push(i):this._events[o]=[this._events[o],i]:this._events[o]=i,q(this._events[o])&&!this._events[o].warned&&(ee(this._maxListeners)?e=d.defaultMaxListeners:e=this._maxListeners,e&&e>0&&this._events[o].length>e&&(this._events[o].warned=!0,console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",this._events[o].length),typeof console.trace=="function"&&console.trace())),this},d.prototype.on=d.prototype.addListener,d.prototype.once=function(o,i){if(!I(i))throw TypeError("listener must be a function");var e=!1;function t(){this.removeListener(o,t),e||(e=!0,i.apply(this,arguments))}return t.listener=i,this.on(o,t),this},d.prototype.removeListener=function(o,i){var e,t,s,r;if(!I(i))throw TypeError("listener must be a function");if(!this._events||!this._events[o])return this;if(e=this._events[o],s=e.length,t=-1,e===i||I(e.listener)&&e.listener===i)delete this._events[o],this._events.removeListener&&this.emit("removeListener",o,i);else if(q(e)){for(r=s;r-- >0;)if(e[r]===i||e[r].listener&&e[r].listener===i){t=r;break}if(t<0)return this;e.length===1?(e.length=0,delete this._events[o]):e.splice(t,1),this._events.removeListener&&this.emit("removeListener",o,i)}return this},d.prototype.removeAllListeners=function(o){var i,e;if(!this._events)return this;if(!this._events.removeListener)return arguments.length===0?this._events={}:this._events[o]&&delete this._events[o],this;if(arguments.length===0){for(i in this._events)i!=="removeListener"&&this.removeAllListeners(i);return this.removeAllListeners("removeListener"),this._events={},this}if(e=this._events[o],I(e))this.removeListener(o,e);else if(e)for(;e.length;)this.removeListener(o,e[e.length-1]);return delete this._events[o],this},d.prototype.listeners=function(o){var i;return!this._events||!this._events[o]?i=[]:I(this._events[o])?i=[this._events[o]]:i=this._events[o].slice(),i},d.prototype.listenerCount=function(o){if(this._events){var i=this._events[o];if(I(i))return 1;if(i)return i.length}return 0},d.listenerCount=function(o,i){return o.listenerCount(i)};function I(o){return typeof o=="function"}function We(o){return typeof o=="number"}function q(o){return typeof o=="object"&&o!==null}function ee(o){return o===void 0}const Y="wc",X=2,H="client",T=`${Y}@${X}:${H}:`,$={name:H,logger:"error",controller:!1,relayUrl:"wss://relay.walletconnect.com"},Ze={session_proposal:"session_proposal",session_update:"session_update",session_extend:"session_extend",session_ping:"session_ping",pairing_ping:"pairing_ping",session_delete:"session_delete",session_expire:"session_expire",pairing_delete:"pairing_delete",pairing_expire:"pairing_expire",session_request:"session_request",session_event:"session_event",proposal_expire:"proposal_expire"},Be={database:":memory:"},te="expirer",m={created:"expirer_created",deleted:"expirer_deleted",expired:"expirer_expired",sync:"expirer_sync"},se="0.3",Qe=Ue,_={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},ie="history",re="0.3",ne="pairing",et=B,oe="proposal",ae=B,ce="session",L=ke,he="engine",G={wc_pairingDelete:{req:{prompt:!1,tag:1e3},res:{prompt:!1,tag:1001}},wc_pairingPing:{req:{prompt:!1,tag:1002},res:{prompt:!1,tag:1003}},wc_sessionPropose:{req:{prompt:!0,tag:1100},res:{prompt:!1,tag:1101}},wc_sessionSettle:{req:{prompt:!1,tag:1102},res:{prompt:!1,tag:1103}},wc_sessionUpdate:{req:{prompt:!1,tag:1104},res:{prompt:!1,tag:1105}},wc_sessionExtend:{req:{prompt:!1,tag:1106},res:{prompt:!1,tag:1107}},wc_sessionRequest:{req:{prompt:!0,tag:1108},res:{prompt:!1,tag:1109}},wc_sessionEvent:{req:{prompt:!0,tag:1110},res:{prompt:!1,tag:1111}},wc_sessionDelete:{req:{prompt:!1,tag:1112},res:{prompt:!1,tag:1113}},wc_sessionPing:{req:{prompt:!1,tag:1114},res:{prompt:!1,tag:1115}}};var tt=Object.defineProperty,st=Object.defineProperties,it=Object.getOwnPropertyDescriptors,le=Object.getOwnPropertySymbols,rt=Object.prototype.hasOwnProperty,nt=Object.prototype.propertyIsEnumerable,pe=(o,i,e)=>i in o?tt(o,i,{enumerable:!0,configurable:!0,writable:!0,value:e}):o[i]=e,N=(o,i)=>{for(var e in i||(i={}))rt.call(i,e)&&pe(o,e,i[e]);if(le)for(var e of le(i))nt.call(i,e)&&pe(o,e,i[e]);return o},de=(o,i)=>st(o,it(i));class ot extends we{constructor(i){super(i),this.events=new C,this.initialized=!1,this.name=he,this.init=async()=>{this.initialized||(await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.initialized=!0)},this.connect=async e=>{this.isInitialized(),await this.isValidConnect(e);const{pairingTopic:t,requiredNamespaces:s,relays:r}=e;let n=t,a,h=!1;if(n&&(h=this.client.pairing.get(n).active),!n||!h){const{topic:R,uri:g}=await this.createPairing();n=R,a=g}const l=await this.client.core.crypto.generateKeyPair(),w={requiredNamespaces:s,relays:r??[{protocol:F}],proposer:{publicKey:l,metadata:this.client.metadata}},{reject:y,resolve:O,done:M}=x();if(this.events.once(p("session_connect"),async({error:R,session:g})=>{if(R)y(R);else if(g){g.self.publicKey=l;const V=de(N({},g),{requiredNamespaces:s});await this.client.session.set(g.topic,V),await this.setExpiry(g.topic,g.expiry),n&&await this.client.pairing.update(n,{peerMetadata:g.peer.metadata}),O(V)}}),!n){const{message:R}=c("NO_MATCHING_KEY",`connect() pairing topic: ${n}`);throw new Error(R)}const D=await this.sendRequest(n,"wc_sessionPropose",w),K=E(A);return await this.setProposal(D,N({id:D,expiry:K},w)),{uri:a,approval:M}},this.pair=async e=>{this.isInitialized(),this.isValidPair(e);const{topic:t,symKey:s,relay:r}=fe(e.uri),n=E(A),a={topic:t,relay:r,expiry:n,active:!1};return await this.client.pairing.set(t,a),await this.client.core.crypto.setSymKey(s,t),await this.client.core.relayer.subscribe(t,{relay:r}),await this.setExpiry(t,n),a},this.approve=async e=>{this.isInitialized(),await this.isValidApprove(e);const{id:t,relayProtocol:s,namespaces:r}=e,{pairingTopic:n,proposer:a,requiredNamespaces:h}=this.client.proposal.get(t),l=await this.client.core.crypto.generateKeyPair(),w=a.publicKey,y=await this.client.core.crypto.generateSharedKey(l,w),O={relay:{protocol:s??"irn"},namespaces:r,requiredNamespaces:h,controller:{publicKey:l,metadata:this.client.metadata},expiry:E(L)};await this.client.core.relayer.subscribe(y);const M=await this.sendRequest(y,"wc_sessionSettle",O),{done:D,resolve:K,reject:R}=x();this.events.once(p("session_approve",M),({error:V})=>{V?R(V):K(this.client.session.get(y))});const g=de(N({},O),{topic:y,acknowledged:!1,self:O.controller,peer:{publicKey:a.publicKey,metadata:a.metadata},controller:l});return await this.client.session.set(y,g),await this.setExpiry(y,E(L)),n&&await this.client.pairing.update(n,{peerMetadata:g.peer.metadata}),n&&t&&(await this.sendResult(t,n,{relay:{protocol:s??"irn"},responderPublicKey:l}),await this.client.proposal.delete(t,f("USER_DISCONNECTED")),await this.activatePairing(n)),{topic:y,acknowledged:D}},this.reject=async e=>{this.isInitialized(),await this.isValidReject(e);const{id:t,reason:s}=e,{pairingTopic:r}=this.client.proposal.get(t);r&&(await this.sendError(t,r,s),await this.client.proposal.delete(t,f("USER_DISCONNECTED")))},this.update=async e=>{this.isInitialized(),await this.isValidUpdate(e);const{topic:t,namespaces:s}=e,r=await this.sendRequest(t,"wc_sessionUpdate",{namespaces:s}),{done:n,resolve:a,reject:h}=x();return this.events.once(p("session_update",r),({error:l})=>{l?h(l):a()}),await this.client.session.update(t,{namespaces:s}),{acknowledged:n}},this.extend=async e=>{this.isInitialized(),await this.isValidExtend(e);const{topic:t}=e,s=await this.sendRequest(t,"wc_sessionExtend",{}),{done:r,resolve:n,reject:a}=x();return this.events.once(p("session_extend",s),({error:h})=>{h?a(h):n()}),await this.setExpiry(t,E(L)),{acknowledged:r}},this.request=async e=>{this.isInitialized(),await this.isValidRequest(e);const{chainId:t,request:s,topic:r}=e,n=await this.sendRequest(r,"wc_sessionRequest",{request:s,chainId:t}),{done:a,resolve:h,reject:l}=x();return this.events.once(p("session_request",n),({error:w,result:y})=>{w?l(w):h(y)}),await a()},this.respond=async e=>{this.isInitialized(),await this.isValidRespond(e);const{topic:t,response:s}=e,{id:r}=s;S(s)?await this.sendResult(r,t,s.result):v(s)&&await this.sendError(r,t,s.error)},this.ping=async e=>{this.isInitialized(),await this.isValidPing(e);const{topic:t}=e;if(this.client.session.keys.includes(t)){const s=await this.sendRequest(t,"wc_sessionPing",{}),{done:r,resolve:n,reject:a}=x();this.events.once(p("session_ping",s),({error:h})=>{h?a(h):n()}),await r()}else if(this.client.pairing.keys.includes(t)){const s=await this.sendRequest(t,"wc_pairingPing",{}),{done:r,resolve:n,reject:a}=x();this.events.once(p("pairing_ping",s),({error:h})=>{h?a(h):n()}),await r()}},this.emit=async e=>{this.isInitialized(),await this.isValidEmit(e);const{topic:t,event:s,chainId:r}=e;await this.sendRequest(t,"wc_sessionEvent",{event:s,chainId:r})},this.disconnect=async e=>{this.isInitialized(),await this.isValidDisconnect(e);const{topic:t}=e;this.client.session.keys.includes(t)?(await this.sendRequest(t,"wc_sessionDelete",f("USER_DISCONNECTED")),await this.deleteSession(t)):this.client.pairing.keys.includes(t)&&(await this.sendRequest(t,"wc_pairingDelete",f("USER_DISCONNECTED")),await this.deletePairing(t))},this.find=e=>(this.isInitialized(),this.client.session.getAll().filter(t=>ve(t,e))),this.activatePairing=async e=>{const t=E(ae);await this.client.pairing.update(e,{active:!0,expiry:t}),await this.setExpiry(e,t)},this.deleteSession=async e=>{const{self:t}=this.client.session.get(e);await this.client.core.relayer.unsubscribe(e),await Promise.all([this.client.session.delete(e,f("USER_DISCONNECTED")),this.client.core.crypto.deleteKeyPair(t.publicKey),this.client.core.crypto.deleteSymKey(e),this.client.expirer.del(e)])},this.deletePairing=async e=>{await this.client.core.relayer.unsubscribe(e),await Promise.all([this.client.pairing.delete(e,f("USER_DISCONNECTED")),this.client.core.crypto.deleteSymKey(e),this.client.expirer.del(e)])},this.deleteProposal=async e=>{await Promise.all([this.client.proposal.delete(e,f("USER_DISCONNECTED")),this.client.expirer.del(e)])},this.setExpiry=async(e,t)=>{this.client.pairing.keys.includes(e)?await this.client.pairing.update(e,{expiry:t}):this.client.session.keys.includes(e)&&await this.client.session.update(e,{expiry:t}),this.client.expirer.set(e,t)},this.setProposal=async(e,t)=>{await this.client.proposal.set(e,t),this.client.expirer.set(e,t.expiry)},this.sendRequest=async(e,t,s)=>{const r=Q(t,s),n=await this.client.core.crypto.encode(e,r),a=G[t].req;return this.client.history.set(e,r),await this.client.core.relayer.publish(e,n,a),r.id},this.sendResult=async(e,t,s)=>{const r=Je(e,s),n=await this.client.core.crypto.encode(t,r),a=await this.client.history.get(t,e),h=G[a.request.method].res;await this.client.core.relayer.publish(t,n,h),await this.client.history.resolve(r)},this.sendError=async(e,t,s)=>{const r=Ye(e,s),n=await this.client.core.crypto.encode(t,r),a=await this.client.history.get(t,e),h=G[a.request.method].res;await this.client.core.relayer.publish(t,n,h),await this.client.history.resolve(r)},this.cleanup=async()=>{const e=[],t=[],s=[];this.client.session.getAll().forEach(r=>{P(r.expiry)&&e.push(r.topic)}),this.client.pairing.getAll().forEach(r=>{P(r.expiry)&&t.push(r.topic)}),this.client.proposal.getAll().forEach(r=>{P(r.expiry)&&s.push(r.id)}),await Promise.all([...e.map(this.deleteSession),...t.map(this.deletePairing),...s.map(this.deleteProposal)])},this.onRelayEventRequest=e=>{const{topic:t,payload:s}=e,r=s.method;switch(r){case"wc_sessionPropose":return this.onSessionProposeRequest(t,s);case"wc_sessionSettle":return this.onSessionSettleRequest(t,s);case"wc_sessionUpdate":return this.onSessionUpdateRequest(t,s);case"wc_sessionExtend":return this.onSessionExtendRequest(t,s);case"wc_sessionPing":return this.onSessionPingRequest(t,s);case"wc_pairingPing":return this.onPairingPingRequest(t,s);case"wc_sessionDelete":return this.onSessionDeleteRequest(t,s);case"wc_pairingDelete":return this.onPairingDeleteRequest(t,s);case"wc_sessionRequest":return this.onSessionRequest(t,s);case"wc_sessionEvent":return this.onSessionEventRequest(t,s);default:return this.client.logger.info(`Unsupported request method ${r}`)}},this.onRelayEventResponse=async e=>{const{topic:t,payload:s}=e,r=(await this.client.history.get(t,s.id)).request.method;switch(r){case"wc_sessionPropose":return this.onSessionProposeResponse(t,s);case"wc_sessionSettle":return this.onSessionSettleResponse(t,s);case"wc_sessionUpdate":return this.onSessionUpdateResponse(t,s);case"wc_sessionExtend":return this.onSessionExtendResponse(t,s);case"wc_sessionPing":return this.onSessionPingResponse(t,s);case"wc_pairingPing":return this.onPairingPingResponse(t,s);case"wc_sessionRequest":return this.onSessionRequestResponse(t,s);default:return this.client.logger.info(`Unsupported response method ${r}`)}},this.onSessionProposeRequest=async(e,t)=>{const{params:s,id:r}=t;try{this.isValidConnect(N({},t.params));const n=E(A),a=N({id:r,pairingTopic:e,expiry:n},s);await this.setProposal(r,a),this.client.events.emit("session_proposal",{id:r,params:a})}catch(n){await this.sendError(r,e,n),this.client.logger.error(n)}},this.onSessionProposeResponse=async(e,t)=>{const{id:s}=t;if(S(t)){const{result:r}=t;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",result:r});const n=this.client.proposal.get(s);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",proposal:n});const a=n.proposer.publicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",selfPublicKey:a});const h=r.responderPublicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",peerPublicKey:h});const l=await this.client.core.crypto.generateSharedKey(a,h);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",sessionTopic:l});const w=await this.client.core.relayer.subscribe(l);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",subscriptionId:w}),await this.activatePairing(e)}else v(t)&&(await this.client.proposal.delete(s,f("USER_DISCONNECTED")),this.events.emit(p("session_connect"),{error:t.error}))},this.onSessionSettleRequest=async(e,t)=>{const{id:s,params:r}=t;try{this.isValidSessionSettleRequest(r);const{relay:n,controller:a,expiry:h,namespaces:l}=t.params,w={topic:e,relay:n,expiry:h,namespaces:l,acknowledged:!0,controller:a.publicKey,self:{publicKey:"",metadata:this.client.metadata},peer:{publicKey:a.publicKey,metadata:a.metadata}};await this.sendResult(t.id,e,!0),this.events.emit(p("session_connect"),{session:w})}catch(n){await this.sendError(s,e,n),this.client.logger.error(n)}},this.onSessionSettleResponse=async(e,t)=>{const{id:s}=t;S(t)?(await this.client.session.update(e,{acknowledged:!0}),this.events.emit(p("session_approve",s),{})):v(t)&&(await this.client.session.delete(e,f("USER_DISCONNECTED")),this.events.emit(p("session_approve",s),{error:t.error}))},this.onSessionUpdateRequest=async(e,t)=>{const{params:s,id:r}=t;try{this.isValidUpdate(N({topic:e},s)),await this.client.session.update(e,{namespaces:s.namespaces}),await this.sendResult(r,e,!0),this.client.events.emit("session_update",{id:r,topic:e,params:s})}catch(n){await this.sendError(r,e,n),this.client.logger.error(n)}},this.onSessionUpdateResponse=(e,t)=>{const{id:s}=t;S(t)?this.events.emit(p("session_update",s),{}):v(t)&&this.events.emit(p("session_update",s),{error:t.error})},this.onSessionExtendRequest=async(e,t)=>{const{id:s}=t;try{this.isValidExtend({topic:e}),await this.setExpiry(e,E(L)),await this.sendResult(s,e,!0),this.client.events.emit("session_extend",{id:s,topic:e})}catch(r){await this.sendError(s,e,r),this.client.logger.error(r)}},this.onSessionExtendResponse=(e,t)=>{const{id:s}=t;S(t)?this.events.emit(p("session_extend",s),{}):v(t)&&this.events.emit(p("session_extend",s),{error:t.error})},this.onSessionPingRequest=async(e,t)=>{const{id:s}=t;try{this.isValidPing({topic:e}),await this.sendResult(s,e,!0),this.client.events.emit("session_ping",{id:s,topic:e})}catch(r){await this.sendError(s,e,r),this.client.logger.error(r)}},this.onSessionPingResponse=(e,t)=>{const{id:s}=t;S(t)?this.events.emit(p("session_ping",s),{}):v(t)&&this.events.emit(p("session_ping",s),{error:t.error})},this.onPairingPingRequest=async(e,t)=>{const{id:s}=t;try{this.isValidPing({topic:e}),await this.sendResult(s,e,!0),this.client.events.emit("pairing_ping",{id:s,topic:e})}catch(r){await this.sendError(s,e,r),this.client.logger.error(r)}},this.onPairingPingResponse=(e,t)=>{const{id:s}=t;S(t)?this.events.emit(p("pairing_ping",s),{}):v(t)&&this.events.emit(p("pairing_ping",s),{error:t.error})},this.onSessionDeleteRequest=async(e,t)=>{const{id:s}=t;try{this.isValidDisconnect({topic:e,reason:t.params}),await this.sendResult(s,e,!0),await this.deleteSession(e),this.client.events.emit("session_delete",{id:s,topic:e})}catch(r){await this.sendError(s,e,r),this.client.logger.error(r)}},this.onPairingDeleteRequest=async(e,t)=>{const{id:s}=t;try{this.isValidDisconnect({topic:e,reason:t.params}),await this.sendResult(s,e,!0),await this.deletePairing(e),this.client.events.emit("pairing_delete",{id:s,topic:e})}catch(r){await this.sendError(s,e,r),this.client.logger.error(r)}},this.onSessionRequest=async(e,t)=>{const{id:s,params:r}=t;try{this.isValidRequest(N({topic:e},r)),this.client.events.emit("session_request",{id:s,topic:e,params:r})}catch(n){await this.sendError(s,e,n),this.client.logger.error(n)}},this.onSessionRequestResponse=(e,t)=>{const{id:s}=t;S(t)?this.events.emit(p("session_request",s),{result:t.result}):v(t)&&this.events.emit(p("session_request",s),{error:t.error})},this.onSessionEventRequest=async(e,t)=>{const{id:s,params:r}=t;try{this.isValidEmit(N({topic:e},r)),this.client.events.emit("session_event",{id:s,topic:e,params:r})}catch(n){await this.sendError(s,e,n),this.client.logger.error(n)}},this.isValidConnect=async e=>{if(!u(e)){const{message:a}=c("MISSING_OR_INVALID",`connect() params: ${JSON.stringify(e)}`);throw new Error(a)}const{pairingTopic:t,requiredNamespaces:s,relays:r}=e;Ie(t)||await this.isValidPairingTopic(t);const n=Re(s,"connect()");if(n)throw new Error(n.message);if(!Se(r,!0)){const{message:a}=c("MISSING_OR_INVALID",`connect() relays: ${r}`);throw new Error(a)}},this.isValidPair=e=>{if(!u(e)){const{message:t}=c("MISSING_OR_INVALID",`pair() params: ${e}`);throw new Error(t)}if(!Ne(e.uri)){const{message:t}=c("MISSING_OR_INVALID",`pair() uri: ${e.uri}`);throw new Error(t)}},this.isValidApprove=async e=>{if(!u(e))throw new Error(c("MISSING_OR_INVALID",`approve() params: ${e}`).message);const{id:t,namespaces:s,relayProtocol:r}=e;await this.isValidProposalId(t);const n=this.client.proposal.get(t),a=J(s,"approve()");if(a)throw new Error(a.message);const h=W(n.requiredNamespaces,s,"update()");if(h)throw new Error(h.message);if(!b(r,!0)){const{message:l}=c("MISSING_OR_INVALID",`approve() relayProtocol: ${r}`);throw new Error(l)}},this.isValidReject=async e=>{if(!u(e)){const{message:r}=c("MISSING_OR_INVALID",`reject() params: ${e}`);throw new Error(r)}const{id:t,reason:s}=e;if(await this.isValidProposalId(t),!xe(s)){const{message:r}=c("MISSING_OR_INVALID",`reject() reason: ${JSON.stringify(s)}`);throw new Error(r)}},this.isValidSessionSettleRequest=e=>{if(!u(e)){const{message:l}=c("MISSING_OR_INVALID",`onSessionSettleRequest() params: ${e}`);throw new Error(l)}const{relay:t,controller:s,namespaces:r,expiry:n}=e;if(!Pe(t)){const{message:l}=c("MISSING_OR_INVALID","onSessionSettleRequest() relay protocol should be a string");throw new Error(l)}const a=Te(s,"onSessionSettleRequest()");if(a)throw new Error(a.message);const h=J(r,"onSessionSettleRequest()");if(h)throw new Error(h.message);if(P(n)){const{message:l}=c("EXPIRED","onSessionSettleRequest()");throw new Error(l)}},this.isValidUpdate=async e=>{if(!u(e)){const{message:h}=c("MISSING_OR_INVALID",`update() params: ${e}`);throw new Error(h)}const{topic:t,namespaces:s}=e;await this.isValidSessionTopic(t);const r=this.client.session.get(t),n=J(s,"update()");if(n)throw new Error(n.message);const a=W(r.requiredNamespaces,s,"update()");if(a)throw new Error(a.message)},this.isValidExtend=async e=>{if(!u(e)){const{message:s}=c("MISSING_OR_INVALID",`extend() params: ${e}`);throw new Error(s)}const{topic:t}=e;await this.isValidSessionTopic(t)},this.isValidRequest=async e=>{if(!u(e)){const{message:a}=c("MISSING_OR_INVALID",`request() params: ${e}`);throw new Error(a)}const{topic:t,request:s,chainId:r}=e;await this.isValidSessionTopic(t);const{namespaces:n}=this.client.session.get(t);if(!Z(n,r)){const{message:a}=c("MISSING_OR_INVALID",`request() chainId: ${r}`);throw new Error(a)}if(!Oe(s)){const{message:a}=c("MISSING_OR_INVALID",`request() ${JSON.stringify(s)}`);throw new Error(a)}if(!Ve(n,r,s.method)){const{message:a}=c("MISSING_OR_INVALID",`request() method: ${s.method}`);throw new Error(a)}},this.isValidRespond=async e=>{if(!u(e)){const{message:r}=c("MISSING_OR_INVALID",`respond() params: ${e}`);throw new Error(r)}const{topic:t,response:s}=e;if(await this.isValidSessionTopic(t),!qe(s)){const{message:r}=c("MISSING_OR_INVALID",`respond() response: ${JSON.stringify(s)}`);throw new Error(r)}},this.isValidPing=async e=>{if(!u(e)){const{message:s}=c("MISSING_OR_INVALID",`ping() params: ${e}`);throw new Error(s)}const{topic:t}=e;await this.isValidSessionOrPairingTopic(t)},this.isValidEmit=async e=>{if(!u(e)){const{message:a}=c("MISSING_OR_INVALID",`emit() params: ${e}`);throw new Error(a)}const{topic:t,event:s,chainId:r}=e;await this.isValidSessionTopic(t);const{namespaces:n}=this.client.session.get(t);if(!Z(n,r)){const{message:a}=c("MISSING_OR_INVALID",`emit() chainId: ${r}`);throw new Error(a)}if(!Le(s)){const{message:a}=c("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(s)}`);throw new Error(a)}if(!De(n,r,s.name)){const{message:a}=c("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(s)}`);throw new Error(a)}},this.isValidDisconnect=async e=>{if(!u(e)){const{message:s}=c("MISSING_OR_INVALID",`disconnect() params: ${e}`);throw new Error(s)}const{topic:t}=e;await this.isValidSessionOrPairingTopic(t)}}async createPairing(){const i=be(),e=await this.client.core.crypto.setSymKey(i),t=E(A),s={protocol:F},r={topic:e,expiry:t,relay:s,active:!1},n=Ae({protocol:this.client.protocol,version:this.client.version,topic:e,symKey:i,relay:s});return await this.client.pairing.set(e,r),await this.client.core.relayer.subscribe(e),await this.setExpiry(e,t),{topic:e,uri:n}}isInitialized(){if(!this.initialized){const{message:i}=c("NOT_INITIALIZED",this.name);throw new Error(i)}}registerRelayerEvents(){this.client.core.relayer.on(ge.message,async i=>{const{topic:e,message:t}=i,s=await this.client.core.crypto.decode(e,t);Xe(s)?(this.client.history.set(e,s),this.onRelayEventRequest({topic:e,payload:s})):He(s)&&(await this.client.history.resolve(s),this.onRelayEventResponse({topic:e,payload:s}))})}registerExpirerEvents(){this.client.expirer.on(m.expired,async i=>{const{topic:e,id:t}=Ce(i.target);e?this.client.session.keys.includes(e)?(await this.deleteSession(e),this.client.events.emit("session_expire",{topic:e})):this.client.pairing.keys.includes(e)&&(await this.deletePairing(e),this.client.events.emit("pairing_expire",{topic:e})):t&&await this.deleteProposal(t)})}async isValidPairingTopic(i){if(!b(i,!1)){const{message:e}=c("MISSING_OR_INVALID",`pairing topic should be a string: ${i}`);throw new Error(e)}if(!this.client.pairing.keys.includes(i)){const{message:e}=c("NO_MATCHING_KEY",`pairing topic doesn't exist: ${i}`);throw new Error(e)}if(P(this.client.pairing.get(i).expiry)){await this.deletePairing(i);const{message:e}=c("EXPIRED",`pairing topic: ${i}`);throw new Error(e)}}async isValidSessionTopic(i){if(!b(i,!1)){const{message:e}=c("MISSING_OR_INVALID",`session topic should be a string: ${i}`);throw new Error(e)}if(!this.client.session.keys.includes(i)){const{message:e}=c("NO_MATCHING_KEY",`session topic doesn't exist: ${i}`);throw new Error(e)}if(P(this.client.session.get(i).expiry)){await this.deleteSession(i);const{message:e}=c("EXPIRED",`session topic: ${i}`);throw new Error(e)}}async isValidSessionOrPairingTopic(i){if(this.client.session.keys.includes(i))await this.isValidSessionTopic(i);else if(this.client.pairing.keys.includes(i))await this.isValidPairingTopic(i);else if(b(i,!1)){const{message:e}=c("NO_MATCHING_KEY",`session or pairing topic doesn't exist: ${i}`);throw new Error(e)}else{const{message:e}=c("MISSING_OR_INVALID",`session or pairing topic should be a string: ${i}`);throw new Error(e)}}async isValidProposalId(i){if(!$e(i)){const{message:e}=c("MISSING_OR_INVALID",`proposal id should be a number: ${i}`);throw new Error(e)}if(!this.client.proposal.keys.includes(i)){const{message:e}=c("NO_MATCHING_KEY",`proposal id doesn't exist: ${i}`);throw new Error(e)}if(P(this.client.proposal.get(i).expiry)){await this.deleteProposal(i);const{message:e}=c("EXPIRED",`proposal id: ${i}`);throw new Error(e)}}}class at extends ye{constructor(i,e){super(i,e),this.core=i,this.logger=e,this.expirations=new Map,this.events=new C.EventEmitter,this.name=te,this.version=se,this.cached=[],this.initialized=!1,this.storagePrefix=T,this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(t=>this.expirations.set(t.target,t)),this.cached=[],this.registerEventListeners(),this.initialized=!0)},this.has=t=>{try{const s=this.formatTarget(t);return typeof this.getExpiration(s)<"u"}catch{return!1}},this.set=(t,s)=>{this.isInitialized();const r=this.formatTarget(t),n={target:r,expiry:s};this.expirations.set(r,n),this.checkExpiry(r,n),this.events.emit(m.created,{target:r,expiration:n})},this.get=t=>{this.isInitialized();const s=this.formatTarget(t);return this.getExpiration(s)},this.del=t=>{this.isInitialized();const s=this.formatTarget(t);if(this.has(s)){const r=this.getExpiration(s);this.expirations.delete(s),this.events.emit(m.deleted,{target:s,expiration:r})}},this.on=(t,s)=>{this.events.on(t,s)},this.once=(t,s)=>{this.events.once(t,s)},this.off=(t,s)=>{this.events.off(t,s)},this.removeListener=(t,s)=>{this.events.removeListener(t,s)},this.logger=k(e,this.name)}get context(){return j(this.logger)}get storageKey(){return this.storagePrefix+this.version+"//"+this.name}get length(){return this.expirations.size}get keys(){return Array.from(this.expirations.keys())}get values(){return Array.from(this.expirations.values())}formatTarget(i){if(typeof i=="string")return Ge(i);if(typeof i=="number")return ze(i);const{message:e}=c("UNKNOWN_TYPE",`Target type: ${typeof i}`);throw new Error(e)}async setExpirations(i){await this.core.storage.setItem(this.storageKey,i)}async getExpirations(){return await this.core.storage.getItem(this.storageKey)}async persist(){await this.setExpirations(this.values),this.events.emit(m.sync)}async restore(){try{const i=await this.getExpirations();if(typeof i>"u"||!i.length)return;if(this.expirations.size){const{message:e}=c("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(e),new Error(e)}this.cached=i,this.logger.debug(`Successfully Restored expirations for ${this.name}`),this.logger.trace({type:"method",method:"restore",expirations:this.values})}catch(i){this.logger.debug(`Failed to Restore expirations for ${this.name}`),this.logger.error(i)}}getExpiration(i){const e=this.expirations.get(i);if(!e){const{message:t}=c("NO_MATCHING_KEY",`${this.name}: ${i}`);throw this.logger.error(t),new Error(t)}return e}checkExpiry(i,e){const{expiry:t}=e;je(t)-Date.now()<=0&&this.expire(i,e)}expire(i,e){this.expirations.delete(i),this.events.emit(m.expired,{target:i,expiration:e})}checkExpirations(){this.expirations.forEach((i,e)=>this.checkExpiry(e,i))}registerEventListeners(){this.core.heartbeat.on(Fe.pulse,()=>this.checkExpirations()),this.events.on(m.created,i=>{const e=m.created;this.logger.info(`Emitting ${e}`),this.logger.debug({type:"event",event:e,data:i}),this.persist()}),this.events.on(m.expired,i=>{const e=m.expired;this.logger.info(`Emitting ${e}`),this.logger.debug({type:"event",event:e,data:i}),this.persist()}),this.events.on(m.deleted,i=>{const e=m.deleted;this.logger.info(`Emitting ${e}`),this.logger.debug({type:"event",event:e,data:i}),this.persist()})}isInitialized(){if(!this.initialized){const{message:i}=c("NOT_INITIALIZED",this.name);throw new Error(i)}}}class ct extends _e{constructor(i,e){super(i,e),this.core=i,this.logger=e,this.records=new Map,this.events=new C.EventEmitter,this.name=ie,this.version=re,this.cached=[],this.initialized=!1,this.storagePrefix=T,this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(t=>this.records.set(t.id,t)),this.cached=[],this.registerEventListeners(),this.initialized=!0)},this.set=(t,s,r)=>{if(this.isInitialized(),this.logger.debug("Setting JSON-RPC request history record"),this.logger.trace({type:"method",method:"set",topic:t,request:s,chainId:r}),this.records.has(s.id))return;const n={id:s.id,topic:t,request:{method:s.method,params:s.params||null},chainId:r};this.records.set(n.id,n),this.events.emit(_.created,n)},this.resolve=async t=>{if(this.isInitialized(),this.logger.debug("Updating JSON-RPC response history record"),this.logger.trace({type:"method",method:"update",response:t}),!this.records.has(t.id))return;const s=await this.getRecord(t.id);typeof s.response>"u"&&(s.response=v(t)?{error:t.error}:{result:t.result},this.records.set(s.id,s),this.events.emit(_.updated,s))},this.get=async(t,s)=>{this.isInitialized(),this.logger.debug("Getting record"),this.logger.trace({type:"method",method:"get",topic:t,id:s});const r=await this.getRecord(s);if(r.topic!==t){const{message:n}=c("MISMATCHED_TOPIC",`${this.name}, ${s}`);throw this.logger.error(n),new Error(n)}return r},this.delete=(t,s)=>{this.isInitialized(),this.logger.debug("Deleting record"),this.logger.trace({type:"method",method:"delete",id:s}),this.values.forEach(r=>{if(r.topic===t){if(typeof s<"u"&&r.id!==s)return;this.records.delete(r.id),this.events.emit(_.deleted,r)}})},this.exists=async(t,s)=>(this.isInitialized(),this.records.has(s)?(await this.getRecord(s)).topic===t:!1),this.on=(t,s)=>{this.events.on(t,s)},this.once=(t,s)=>{this.events.once(t,s)},this.off=(t,s)=>{this.events.off(t,s)},this.removeListener=(t,s)=>{this.events.removeListener(t,s)},this.logger=k(e,this.name)}get context(){return j(this.logger)}get storageKey(){return this.storagePrefix+this.version+"//"+this.name}get size(){return this.records.size}get keys(){return Array.from(this.records.keys())}get values(){return Array.from(this.records.values())}get pending(){const i=[];return this.values.forEach(e=>{if(typeof e.response<"u")return;const t={topic:e.topic,request:Q(e.request.method,e.request.params,e.id),chainId:e.chainId};return i.push(t)}),i}async setJsonRpcRecords(i){await this.core.storage.setItem(this.storageKey,i)}async getJsonRpcRecords(){return await this.core.storage.getItem(this.storageKey)}getRecord(i){this.isInitialized();const e=this.records.get(i);if(!e){const{message:t}=c("NO_MATCHING_KEY",`${this.name}: ${i}`);throw new Error(t)}return e}async persist(){await this.setJsonRpcRecords(this.values),this.events.emit(_.sync)}async restore(){try{const i=await this.getJsonRpcRecords();if(typeof i>"u"||!i.length)return;if(this.records.size){const{message:e}=c("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(e),new Error(e)}this.cached=i,this.logger.debug(`Successfully Restored records for ${this.name}`),this.logger.trace({type:"method",method:"restore",records:this.values})}catch(i){this.logger.debug(`Failed to Restore records for ${this.name}`),this.logger.error(i)}}registerEventListeners(){this.events.on(_.created,i=>{const e=_.created;this.logger.info(`Emitting ${e}`),this.logger.debug({type:"event",event:e,record:i}),this.persist()}),this.events.on(_.updated,i=>{const e=_.updated;this.logger.info(`Emitting ${e}`),this.logger.debug({type:"event",event:e,record:i}),this.persist()}),this.events.on(_.deleted,i=>{const e=_.deleted;this.logger.info(`Emitting ${e}`),this.logger.debug({type:"event",event:e,record:i}),this.persist()})}isInitialized(){if(!this.initialized){const{message:i}=c("NOT_INITIALIZED",this.name);throw new Error(i)}}}class ht extends U{constructor(i,e){super(i,e,ne,T),this.core=i,this.logger=e}}class lt extends U{constructor(i,e){super(i,e,oe,T),this.core=i,this.logger=e}}class pt extends U{constructor(i,e){super(i,e,ce,T),this.core=i,this.logger=e}}class z extends Ee{constructor(i){super(i),this.protocol=Y,this.version=X,this.name=$.name,this.events=new C.EventEmitter,this.on=(t,s)=>this.events.on(t,s),this.once=(t,s)=>this.events.once(t,s),this.off=(t,s)=>this.events.off(t,s),this.removeListener=(t,s)=>this.events.removeListener(t,s),this.connect=async t=>{try{return await this.engine.connect(t)}catch(s){throw this.logger.error(s.message),s}},this.pair=async t=>{try{return await this.engine.pair(t)}catch(s){throw this.logger.error(s.message),s}},this.approve=async t=>{try{return await this.engine.approve(t)}catch(s){throw this.logger.error(s.message),s}},this.reject=async t=>{try{return await this.engine.reject(t)}catch(s){throw this.logger.error(s.message),s}},this.update=async t=>{try{return await this.engine.update(t)}catch(s){throw this.logger.error(s.message),s}},this.extend=async t=>{try{return await this.engine.extend(t)}catch(s){throw this.logger.error(s.message),s}},this.request=async t=>{try{return await this.engine.request(t)}catch(s){throw this.logger.error(s.message),s}},this.respond=async t=>{try{return await this.engine.respond(t)}catch(s){throw this.logger.error(s.message),s}},this.ping=async t=>{try{return await this.engine.ping(t)}catch(s){throw this.logger.error(s.message),s}},this.emit=async t=>{try{return await this.engine.emit(t)}catch(s){throw this.logger.error(s.message),s}},this.disconnect=async t=>{try{return await this.engine.disconnect(t)}catch(s){throw this.logger.error(s.message),s}},this.find=t=>{try{return this.engine.find(t)}catch(s){throw this.logger.error(s.message),s}},this.name=i?.name||$.name,this.metadata=i?.metadata||Me();const e=typeof i?.logger<"u"&&typeof i?.logger!="string"?i.logger:Ke(me({level:i?.logger||$.logger}));this.core=i?.core||new ue(i),this.logger=k(e,this.name),this.pairing=new ht(this.core,this.logger),this.session=new pt(this.core,this.logger),this.proposal=new lt(this.core,this.logger),this.history=new ct(this.core,this.logger),this.expirer=new at(this.core,this.logger),this.engine=new ot(this)}static async init(i){const e=new z(i);return await e.initialize(),e}get context(){return j(this.logger)}async initialize(){this.logger.trace("Initialized");try{await this.core.start(),await this.pairing.init(),await this.session.init(),await this.proposal.init(),await this.history.init(),await this.expirer.init(),await this.engine.init(),this.logger.info("SignClient Initilization Success")}catch(i){throw this.logger.info("SignClient Initilization Failure"),this.logger.error(i.message),i}}}const dt=z;export{he as ENGINE_CONTEXT,G as ENGINE_RPC_OPTS,te as EXPIRER_CONTEXT,Qe as EXPIRER_DEFAULT_TTL,m as EXPIRER_EVENTS,se as EXPIRER_STORAGE_VERSION,ie as HISTORY_CONTEXT,_ as HISTORY_EVENTS,re as HISTORY_STORAGE_VERSION,ne as PAIRING_CONTEXT,et as PAIRING_DEFAULT_TTL,oe as PROPOSAL_CONTEXT,ae as PROPOSAL_EXPIRY,ce as SESSION_CONTEXT,L as SESSION_EXPIRY,H as SIGN_CLIENT_CONTEXT,$ as SIGN_CLIENT_DEFAULT,Ze as SIGN_CLIENT_EVENTS,Y as SIGN_CLIENT_PROTOCOL,Be as SIGN_CLIENT_STORAGE_OPTIONS,T as SIGN_CLIENT_STORAGE_PREFIX,X as SIGN_CLIENT_VERSION,dt as SignClient,z as default};
//# sourceMappingURL=index.es.js.map
